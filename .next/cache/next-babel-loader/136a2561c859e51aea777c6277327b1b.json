{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport { toast } from 'react-toastify';\n/* eslint-disable array-callback-return */\n// HOW THESE FUNCTIONS WORK\n// Each nested validation function takes these three props - component state, a validation state setter, and a set validation function\n// Component state is self-explanatory - it's a copy of the entire component state\n// The validation state setter refers to a function in the component that sets updated validation state and dispatches the set validation function as a callback\n// nestedEditFieldValidation takes updatedInstance as an additional prop - this is the state instance the user has been updating in edit mode\n// We set an initial validation boolean that will be switched to false if an invalid field is found\n// We also create a shallow copy of the component's validation map\n// With the nested functions, we map through the validation state and each object contained within for that component's nested state: for example, ownerContactInfo, locationContactInfo, and locationBranding\n// Both functions check if the component state has valid input, referred to by field, and whether that key/field is required - the edit variation checks the user-updated state\n// If an invalid input is found, that boolean in the validation map is set to false, along with validForm\n// The validation state setter is dispatched with the updated validation map\n// The set validation function is passed down from the container level and provides the component with the toast displaying all invalid fields\n\nexport const nestedEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(fieldSection => {\n    if (!updatedInstance[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(field => {\n      if (!updatedInstance[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const shallowEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(field => {\n    if (!updatedInstance[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const nestedCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(fieldSection => {\n    if (!componentState[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(field => {\n      if (!componentState[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const shallowCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(field => {\n    if (!componentState[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n}; // validationState is set in state from the root create or edit when an invalid section is found\n// This function maps through the validation object, checks for invalid fields, and converts them to regular english based on validationFieldMap\n\nexport const parseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n\n  _Object$keys(validationState).map(fieldSection => {\n    if (validationState[fieldSection] === false) {\n      invalidFields.push(validationFieldMap[fieldSection]);\n    }\n\n    _Object$keys(validationState[fieldSection]).map(field => {\n      if (validationState[fieldSection][field] === false) {\n        invalidFields.push(validationFieldMap[field]);\n      }\n    });\n  });\n\n  return invalidFields.join(', ');\n};\nexport const shallowParseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n\n  _Object$keys(validationState).map(field => {\n    if (validationState[field] === false) {\n      invalidFields.push(validationFieldMap[field]);\n    }\n  });\n\n  return invalidFields.join(', ');\n};\nexport const saveNewSuccess = name => toast.success(`Your ${name} has been successfully saved!`, {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success'\n});\nexport const saveChangesSuccess = () => toast.success(\"Your changes have been successfully saved!\", {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success'\n});\nexport const saveNewError = (validationState, validationFieldMap, shallowValidation = false) => toast.error(`Please fill out the following required fields: ${shallowValidation ? shallowParseInvalidFieldsToString(validationState, validationFieldMap) : parseInvalidFieldsToString(validationState, validationFieldMap)}`, {\n  className: 'update-error',\n  progressClassName: 'progress-bar-error'\n});","map":{"version":3,"sources":["/Volumes/HDD/Sites/clearchoicetestprep/clear-choice-admin/components/utils/fieldValidation.js"],"names":["toast","nestedEditFieldValidation","componentState","updatedInstance","validationStateSetter","setValidationFunc","validForm","validation","initialValidation","map","fieldSection","field","shallowEditFieldValidation","nestedCreateFieldValidation","shallowCreateFieldValidation","parseInvalidFieldsToString","validationState","validationFieldMap","invalidFields","push","join","shallowParseInvalidFieldsToString","saveNewSuccess","name","success","className","progressClassName","saveChangesSuccess","saveNewError","shallowValidation","error"],"mappings":"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","sourcesContent":["import { toast } from 'react-toastify';\n/* eslint-disable array-callback-return */\n\n// HOW THESE FUNCTIONS WORK\n// Each nested validation function takes these three props - component state, a validation state setter, and a set validation function\n// Component state is self-explanatory - it's a copy of the entire component state\n// The validation state setter refers to a function in the component that sets updated validation state and dispatches the set validation function as a callback\n// nestedEditFieldValidation takes updatedInstance as an additional prop - this is the state instance the user has been updating in edit mode\n\n// We set an initial validation boolean that will be switched to false if an invalid field is found\n// We also create a shallow copy of the component's validation map\n// With the nested functions, we map through the validation state and each object contained within for that component's nested state: for example, ownerContactInfo, locationContactInfo, and locationBranding\n// Both functions check if the component state has valid input, referred to by field, and whether that key/field is required - the edit variation checks the user-updated state\n// If an invalid input is found, that boolean in the validation map is set to false, along with validForm\n// The validation state setter is dispatched with the updated validation map\n// The set validation function is passed down from the container level and provides the component with the toast displaying all invalid fields\n\nexport const nestedEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(fieldSection => {\n    if (!updatedInstance[fieldSection] && initialValidation[fieldSection]) { initialValidation[fieldSection] = false; }\n    Object.keys(validation[fieldSection]).map(field => {\n      if (!updatedInstance[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\nexport const shallowEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(field => {\n    if (!updatedInstance[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\n\nexport const nestedCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(fieldSection => {\n    if (!componentState[fieldSection] && initialValidation[fieldSection]) { initialValidation[fieldSection] = false; }\n    Object.keys(validation[fieldSection]).map(field => {\n      if (!componentState[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\nexport const shallowCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(field => {\n    if (!componentState[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\n// validationState is set in state from the root create or edit when an invalid section is found\n// This function maps through the validation object, checks for invalid fields, and converts them to regular english based on validationFieldMap\nexport const parseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n  Object.keys(validationState).map(fieldSection => {\n    if (validationState[fieldSection] === false) { invalidFields.push(validationFieldMap[fieldSection]); }\n    Object.keys(validationState[fieldSection]).map(field => {\n      if (validationState[fieldSection][field] === false) {\n        invalidFields.push(validationFieldMap[field]);\n      }\n    });\n  });\n  return invalidFields.join(', ');\n};\n\nexport const shallowParseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n  Object.keys(validationState).map(field => {\n    if (validationState[field] === false) {\n      invalidFields.push(validationFieldMap[field]);\n    }\n  });\n  return invalidFields.join(', ');\n};\n\n\nexport const saveNewSuccess = (name) => toast.success(`Your ${name} has been successfully saved!`, {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success',\n});\nexport const saveChangesSuccess = () => toast.success(\"Your changes have been successfully saved!\", {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success',\n});\nexport const saveNewError = (validationState, validationFieldMap, shallowValidation = false) =>\n  toast.error(\n    `Please fill out the following required fields: ${shallowValidation ? shallowParseInvalidFieldsToString(validationState, validationFieldMap) : parseInvalidFieldsToString(validationState, validationFieldMap)}`, {\n      className: 'update-error',\n      progressClassName: 'progress-bar-error',\n    });\n"]},"metadata":{},"sourceType":"module"}