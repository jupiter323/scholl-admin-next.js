{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport React from 'react';\nimport update from 'immutability-helper';\nimport moment from 'moment';\nimport FilterSection from './components/FilterSection';\nimport TestSectionCard from './components/TestSectionCard';\nimport { availableDateSort, dueDateSort, statusSort, flagsSort, problemSort, timeEstimateSort, subjectSort, percentageCompleteSort } from '../utils/sortOptions';\nimport { testSectionSubjectMap } from '../utils/testSectionCardUtils';\nimport sampleTestSections from '../utils/sampleTestSections';\n\nclass TestSectionsPage extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"onSetSort\", sort => this.setState({\n      sort\n    }));\n\n    _defineProperty(this, \"onClearFilters\", () => this.setState({\n      sort: '',\n      testVersionFilter: '',\n      subjectFilters: [],\n      flagFilter: false,\n      availableDateFilters: [],\n      dueDateFilters: []\n    }));\n\n    _defineProperty(this, \"onSetDropdown\", dropdownIndex => this.setState({\n      dropdownIndex,\n      dropdownIsOpen: true\n    }));\n\n    _defineProperty(this, \"onCloseDropdown\", () => this.setState({\n      dropdownIsOpen: false\n    }));\n\n    _defineProperty(this, \"onSetFilteredState\", value => this.setState({\n      testVersionFilter: value\n    }));\n\n    _defineProperty(this, \"onUnsetFilteredState\", () => this.setState({\n      testVersionFilter: ''\n    }));\n\n    _defineProperty(this, \"onSortTestSections\", testSections => {\n      const {\n        sort\n      } = this.state;\n\n      switch (sort) {\n        case 'flags':\n          return testSections.sort(flagsSort);\n\n        case 'dueDate':\n          return testSections.sort(dueDateSort);\n\n        case 'availableDate':\n          return testSections.sort(availableDateSort);\n\n        case 'status':\n          return testSections.sort(statusSort);\n\n        case 'problems':\n          return testSections.sort(problemSort);\n\n        case 'timeEstimate':\n          return testSections.sort(timeEstimateSort);\n\n        case 'subject':\n          return testSections.sort(subjectSort);\n\n        case 'percentageComplete':\n          return testSections.sort(percentageCompleteSort);\n\n        default:\n          break;\n      }\n    });\n\n    _defineProperty(this, \"onFilterByTestVersion\", () => {\n      const {\n        testSections,\n        testVersionFilter\n      } = this.state;\n      return testSections.reduce((finalArr, currentTestSection) => {\n        const {\n          version\n        } = currentTestSection;\n        const testSectionString = version.replace(/\\s/g, \"\").toLowerCase();\n\n        if (testSectionString.indexOf(testVersionFilter) !== -1 && finalArr.indexOf(currentTestSection) === -1) {\n          finalArr.push(currentTestSection);\n        }\n\n        return finalArr;\n      }, []);\n    });\n\n    _defineProperty(this, \"onFilterByDate\", (incomingSections, dateType) => {\n      const {\n        dueDateFilters,\n        availableDateFilters\n      } = this.state;\n      let dateFilters;\n      let testSections = incomingSections;\n      const currentDate = moment().format('MM/DD/YY');\n      const currentDateIndex = new Date().getDay();\n      const endOfWeekIndex = 6 - currentDateIndex;\n      const endOfWeekDate = moment().add(endOfWeekIndex, 'days').format('MM/DD/YY');\n\n      if (dateType === 'dueDate') {\n        dateFilters = dueDateFilters;\n\n        if (dateFilters.indexOf('dueToday') !== -1) {\n          testSections = testSections.filter(testSection => testSection.dueDate === currentDate);\n        }\n\n        if (dateFilters.indexOf('dueNextSession') !== -1) {\n          console.warn('Pending decision on how next session date is calculated');\n        }\n\n        if (dateFilters.indexOf('overdue') !== -1) {\n          testSections = testSections.filter(testSection => testSection.dueDate < currentDate);\n        }\n\n        if (dateFilters.indexOf('dueThisWeek') !== -1) {\n          testSections = testSections.filter(testSection => testSection.dueDate >= currentDate && testSection.dueDate <= endOfWeekDate);\n        }\n      } else {\n        dateFilters = availableDateFilters;\n\n        if (dateFilters.indexOf('future') !== -1) {\n          testSections = testSections.filter(testSection => testSection.availableDate > currentDate);\n        }\n\n        if (dateFilters.indexOf('available') !== -1) {\n          testSections = testSections.filter(testSection => testSection.availableDate <= currentDate);\n        }\n\n        if (dateFilters.indexOf('complete') !== -1) {\n          testSections = testSections.filter(testSection => testSection.percentageComplete === '100');\n        }\n      }\n\n      return testSections;\n    });\n\n    _defineProperty(this, \"onFilterTestSections\", () => {\n      const {\n        subjectFilters,\n        dueDateFilters,\n        availableDateFilters,\n        flagFilter,\n        testSections: allTestSections\n      } = this.state;\n      let testSections = allTestSections;\n\n      if (subjectFilters.length) {\n        testSections = testSections.filter(testSection => subjectFilters.indexOf(testSectionSubjectMap[testSection.subject]) !== -1);\n      }\n\n      if (dueDateFilters.length) {\n        testSections = this.onFilterByDate(testSections, 'dueDate');\n      }\n\n      if (availableDateFilters.length) {\n        testSections = this.onFilterByDate(testSections, 'availableDate');\n      }\n\n      if (flagFilter) {\n        testSections = testSections.filter(testSection => testSection.flags.length);\n      }\n\n      return testSections;\n    });\n\n    _defineProperty(this, \"getMappableTestSections\", () => {\n      const {\n        subjectFilters,\n        dueDateFilters,\n        availableDateFilters,\n        flagFilter,\n        sort,\n        testVersionFilter,\n        testSections\n      } = this.state;\n      let mappableTestSections = testSections;\n\n      if (testVersionFilter.length) {\n        mappableTestSections = this.onFilterByTestVersion();\n      }\n\n      if (subjectFilters.length || dueDateFilters.length || availableDateFilters.length || flagFilter) {\n        mappableTestSections = this.onFilterTestSections();\n      }\n\n      if (sort) {\n        return this.onSortTestSections(mappableTestSections);\n      }\n\n      return mappableTestSections;\n    });\n\n    _defineProperty(this, \"handleFilterClick\", (filterType, filter) => {\n      const {\n        availableDateFilters: currentAvailableDateFilters,\n        dueDateFilters: currentDueDateFilters,\n        subjectFilters: currentSubjectFilters,\n        flagFilter\n      } = this.state;\n      let modifiedFilterCurrentState;\n      let modifiedFilterName;\n      let modifiedFilterUpdatedState;\n\n      switch (filterType) {\n        case 'subject':\n          modifiedFilterCurrentState = currentSubjectFilters;\n          modifiedFilterName = 'subjectFilters';\n          break;\n\n        case 'dueDate':\n          modifiedFilterCurrentState = currentDueDateFilters;\n          modifiedFilterName = 'dueDateFilters';\n          break;\n\n        case 'availableDate':\n          modifiedFilterCurrentState = currentAvailableDateFilters;\n          modifiedFilterName = 'availableDateFilters';\n          break;\n\n        case 'hasFlags':\n          return this.setState({\n            flagFilter: !flagFilter\n          });\n\n        default:\n          break;\n      }\n\n      if (modifiedFilterCurrentState.indexOf(filter) === -1) {\n        modifiedFilterUpdatedState = update(modifiedFilterCurrentState, {\n          $push: [filter]\n        });\n      } else {\n        const filterIndex = modifiedFilterCurrentState.indexOf(filter);\n        modifiedFilterUpdatedState = update(modifiedFilterCurrentState, {\n          $splice: [[filterIndex, 1]]\n        });\n      }\n\n      this.setState({\n        [modifiedFilterName]: modifiedFilterUpdatedState\n      });\n    });\n\n    _defineProperty(this, \"mapTestSections\", () => this.getMappableTestSections().map((testSection, index) => React.createElement(TestSectionCard, {\n      index: index,\n      key: testSection.id,\n      testSection: testSection,\n      onSetDropdown: this.onSetDropdown,\n      onCloseDropdown: this.onCloseDropdown,\n      dropdownIndex: this.state.dropdownIndex,\n      dropdownIsOpen: this.state.dropdownIsOpen\n    })));\n\n    this.state = {\n      sort: '',\n      testVersionFilter: '',\n      subjectFilters: [],\n      flagFilter: false,\n      availableDateFilters: [],\n      dueDateFilters: [],\n      dropdownIndex: null,\n      dropdownIsOpen: false,\n      testSections: sampleTestSections\n    };\n  }\n\n  render() {\n    const {\n      testSections\n    } = this.state;\n    return React.createElement(React.Fragment, null, React.createElement(FilterSection, {\n      sort: this.state.sort,\n      onSetSort: this.onSetSort,\n      flagFilter: this.state.flagFilter,\n      onClearFilters: this.onClearFilters,\n      handleFilterClick: this.handleFilterClick,\n      subjectFilters: this.state.subjectFilters,\n      dueDateFilters: this.state.dueDateFilters,\n      availableDateFilters: this.state.availableDateFilters,\n      onSetFilteredState: this.onSetFilteredState,\n      onUnsetFilteredState: this.onUnsetFilteredState\n    }), React.createElement(\"div\", {\n      className: \"content-section\"\n    }, React.createElement(\"div\", {\n      className: \"result-row center-align\"\n    }, React.createElement(\"b\", {\n      className: \"result\"\n    }, \" - \", testSections.length, \" results -\")), React.createElement(\"div\", {\n      className: \"row d-flex-content card-width-272\"\n    }, this.mapTestSections())));\n  }\n\n}\n\nexport default TestSectionsPage;","map":null,"metadata":{},"sourceType":"module"}