{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport { toast } from 'react-toastify';\n/* eslint-disable array-callback-return */\n// HOW THESE FUNCTIONS WORK\n// Each nested validation function takes these three props - component state, a validation state setter, and a set validation function\n// Component state is self-explanatory - it's a copy of the entire component state\n// The validation state setter refers to a function in the component that sets updated validation state and dispatches the set validation function as a callback\n// nestedEditFieldValidation takes updatedInstance as an additional prop - this is the state instance the user has been updating in edit mode\n// We set an initial validation boolean that will be switched to false if an invalid field is found\n// We also create a shallow copy of the component's validation map\n// With the nested functions, we map through the validation state and each object contained within for that component's nested state: for example, ownerContactInfo, locationContactInfo, and locationBranding\n// Both functions check if the component state has valid input, referred to by field, and whether that key/field is required - the edit variation checks the user-updated state\n// If an invalid input is found, that boolean in the validation map is set to false, along with validForm\n// The validation state setter is dispatched with the updated validation map\n// The set validation function is passed down from the container level and provides the component with the toast displaying all invalid fields\n\nexport var nestedEditFieldValidation = function nestedEditFieldValidation(componentState, updatedInstance, validationStateSetter, setValidationFunc) {\n  var validForm = true;\n  var validation = componentState.validation;\n\n  var initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(function (fieldSection) {\n    if (!updatedInstance[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(function (field) {\n      if (!updatedInstance[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport var shallowEditFieldValidation = function shallowEditFieldValidation(componentState, updatedInstance, validationStateSetter, setValidationFunc) {\n  var validForm = true;\n  var validation = componentState.validation;\n\n  var initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(function (field) {\n    if (!updatedInstance[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport var nestedCreateFieldValidation = function nestedCreateFieldValidation(componentState, validationStateSetter, setValidationFunc) {\n  var validForm = true;\n  var validation = componentState.validation;\n\n  var initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(function (fieldSection) {\n    if (!componentState[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(function (field) {\n      if (!componentState[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport var shallowCreateFieldValidation = function shallowCreateFieldValidation(componentState, validationStateSetter, setValidationFunc) {\n  var validForm = true;\n  var validation = componentState.validation;\n\n  var initialValidation = _objectSpread({}, validation);\n\n  _Object$keys(validation).map(function (field) {\n    if (!componentState[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n}; // validationState is set in state from the root create or edit when an invalid section is found\n// This function maps through the validation object, checks for invalid fields, and converts them to regular english based on validationFieldMap\n\nexport var parseInvalidFieldsToString = function parseInvalidFieldsToString(validationState, validationFieldMap) {\n  var invalidFields = [];\n\n  _Object$keys(validationState).map(function (fieldSection) {\n    if (validationState[fieldSection] === false) {\n      invalidFields.push(validationFieldMap[fieldSection]);\n    }\n\n    _Object$keys(validationState[fieldSection]).map(function (field) {\n      if (validationState[fieldSection][field] === false) {\n        invalidFields.push(validationFieldMap[field]);\n      }\n    });\n  });\n\n  return invalidFields.join(', ');\n};\nexport var shallowParseInvalidFieldsToString = function shallowParseInvalidFieldsToString(validationState, validationFieldMap) {\n  var invalidFields = [];\n\n  _Object$keys(validationState).map(function (field) {\n    if (validationState[field] === false) {\n      invalidFields.push(validationFieldMap[field]);\n    }\n  });\n\n  return invalidFields.join(', ');\n};\nexport var saveNewSuccess = function saveNewSuccess(name) {\n  return toast.success(\"Your \".concat(name, \" has been successfully saved!\"), {\n    className: 'update-success',\n    progressClassName: 'progress-bar-success'\n  });\n};\nexport var saveChangesSuccess = function saveChangesSuccess() {\n  return toast.success(\"Your changes have been successfully saved!\", {\n    className: 'update-success',\n    progressClassName: 'progress-bar-success'\n  });\n};\nexport var saveNewError = function saveNewError(validationState, validationFieldMap) {\n  var shallowValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return toast.error(\"Please fill out the following required fields: \".concat(shallowValidation ? shallowParseInvalidFieldsToString(validationState, validationFieldMap) : parseInvalidFieldsToString(validationState, validationFieldMap)), {\n    className: 'update-error',\n    progressClassName: 'progress-bar-error'\n  });\n};","map":{"version":3,"sources":["/Users/chrischavarro/clear-choice/clear-choice-admin/components/utils/fieldValidation.js"],"names":["toast","nestedEditFieldValidation","componentState","updatedInstance","validationStateSetter","setValidationFunc","validForm","validation","initialValidation","map","fieldSection","field","shallowEditFieldValidation","nestedCreateFieldValidation","shallowCreateFieldValidation","parseInvalidFieldsToString","validationState","validationFieldMap","invalidFields","push","join","shallowParseInvalidFieldsToString","saveNewSuccess","name","success","className","progressClassName","saveChangesSuccess","saveNewError","shallowValidation","error"],"mappings":"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","sourcesContent":["import { toast } from 'react-toastify';\n/* eslint-disable array-callback-return */\n\n// HOW THESE FUNCTIONS WORK\n// Each nested validation function takes these three props - component state, a validation state setter, and a set validation function\n// Component state is self-explanatory - it's a copy of the entire component state\n// The validation state setter refers to a function in the component that sets updated validation state and dispatches the set validation function as a callback\n// nestedEditFieldValidation takes updatedInstance as an additional prop - this is the state instance the user has been updating in edit mode\n\n// We set an initial validation boolean that will be switched to false if an invalid field is found\n// We also create a shallow copy of the component's validation map\n// With the nested functions, we map through the validation state and each object contained within for that component's nested state: for example, ownerContactInfo, locationContactInfo, and locationBranding\n// Both functions check if the component state has valid input, referred to by field, and whether that key/field is required - the edit variation checks the user-updated state\n// If an invalid input is found, that boolean in the validation map is set to false, along with validForm\n// The validation state setter is dispatched with the updated validation map\n// The set validation function is passed down from the container level and provides the component with the toast displaying all invalid fields\n\nexport const nestedEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(fieldSection => {\n    if (!updatedInstance[fieldSection] && initialValidation[fieldSection]) { initialValidation[fieldSection] = false; }\n    Object.keys(validation[fieldSection]).map(field => {\n      if (!updatedInstance[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\nexport const shallowEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(field => {\n    if (!updatedInstance[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\n\nexport const nestedCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(fieldSection => {\n    if (!componentState[fieldSection] && initialValidation[fieldSection]) { initialValidation[fieldSection] = false; }\n    Object.keys(validation[fieldSection]).map(field => {\n      if (!componentState[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\nexport const shallowCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const { validation } = componentState;\n  const initialValidation = { ...validation };\n\n  Object.keys(validation).map(field => {\n    if (!componentState[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\n\n// validationState is set in state from the root create or edit when an invalid section is found\n// This function maps through the validation object, checks for invalid fields, and converts them to regular english based on validationFieldMap\nexport const parseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n  Object.keys(validationState).map(fieldSection => {\n    if (validationState[fieldSection] === false) { invalidFields.push(validationFieldMap[fieldSection]); }\n    Object.keys(validationState[fieldSection]).map(field => {\n      if (validationState[fieldSection][field] === false) {\n        invalidFields.push(validationFieldMap[field]);\n      }\n    });\n  });\n  return invalidFields.join(', ');\n};\n\nexport const shallowParseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n  Object.keys(validationState).map(field => {\n    if (validationState[field] === false) {\n      invalidFields.push(validationFieldMap[field]);\n    }\n  });\n  return invalidFields.join(', ');\n};\n\n\nexport const saveNewSuccess = (name) => toast.success(`Your ${name} has been successfully saved!`, {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success',\n});\nexport const saveChangesSuccess = () => toast.success(\"Your changes have been successfully saved!\", {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success',\n});\nexport const saveNewError = (validationState, validationFieldMap, shallowValidation = false) =>\n  toast.error(\n    `Please fill out the following required fields: ${shallowValidation ? shallowParseInvalidFieldsToString(validationState, validationFieldMap) : parseInvalidFieldsToString(validationState, validationFieldMap)}`, {\n      className: 'update-error',\n      progressClassName: 'progress-bar-error',\n    });\n"]},"metadata":{},"sourceType":"module"}