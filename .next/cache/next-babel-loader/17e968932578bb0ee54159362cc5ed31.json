{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _objectSpread2 from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport { toast } from 'react-toastify';\n/* eslint-disable array-callback-return */\n// HOW THESE FUNCTIONS WORK\n// Each nested validation function takes these three props - component state, a validation state setter, and a set validation function\n// Component state is self-explanatory - it's a copy of the entire component state\n// The validation state setter refers to a function in the component that sets updated validation state and dispatches the set validation function as a callback\n// nestedEditFieldValidation takes updatedInstance as an additional prop - this is the state instance the user has been updating in edit mode\n// We set an initial validation boolean that will be switched to false if an invalid field is found\n// We also create a shallow copy of the component's validation map\n// With the nested functions, we map through the validation state and each object contained within for that component's nested state: for example, ownerContactInfo, locationContactInfo, and locationBranding\n// Both functions check if the component state has valid input, referred to by field, and whether that key/field is required - the edit variation checks the user-updated state\n// If an invalid input is found, that boolean in the validation map is set to false, along with validForm\n// The validation state setter is dispatched with the updated validation map\n// The set validation function is passed down from the container level and provides the component with the toast displaying all invalid fields\n\nexport const nestedEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread2({}, validation);\n\n  _Object$keys(validation).map(fieldSection => {\n    if (!updatedInstance[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(field => {\n      if (!updatedInstance[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const shallowEditFieldValidation = (componentState, updatedInstance, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread2({}, validation);\n\n  _Object$keys(validation).map(field => {\n    if (!updatedInstance[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const nestedCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread2({}, validation);\n\n  _Object$keys(validation).map(fieldSection => {\n    if (!componentState[fieldSection] && initialValidation[fieldSection]) {\n      initialValidation[fieldSection] = false;\n    }\n\n    _Object$keys(validation[fieldSection]).map(field => {\n      if (!componentState[fieldSection][field] && initialValidation[fieldSection][field]) {\n        initialValidation[fieldSection][field] = false;\n        validForm = false;\n      }\n    });\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n};\nexport const shallowCreateFieldValidation = (componentState, validationStateSetter, setValidationFunc) => {\n  let validForm = true;\n  const {\n    validation\n  } = componentState;\n\n  const initialValidation = _objectSpread2({}, validation);\n\n  _Object$keys(validation).map(field => {\n    if (!componentState[field] && initialValidation[field]) {\n      initialValidation[field] = false;\n      validForm = false;\n    }\n  });\n\n  validationStateSetter(initialValidation, setValidationFunc(initialValidation));\n  return validForm;\n}; // validationState is set in state from the root create or edit when an invalid section is found\n// This function maps through the validation object, checks for invalid fields, and converts them to regular english based on validationFieldMap\n\nexport const parseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n\n  _Object$keys(validationState).map(fieldSection => {\n    if (validationState[fieldSection] === false) {\n      invalidFields.push(validationFieldMap[fieldSection]);\n    }\n\n    _Object$keys(validationState[fieldSection]).map(field => {\n      if (validationState[fieldSection][field] === false) {\n        invalidFields.push(validationFieldMap[field]);\n      }\n    });\n  });\n\n  return invalidFields.join(', ');\n};\nexport const shallowParseInvalidFieldsToString = (validationState, validationFieldMap) => {\n  const invalidFields = [];\n\n  _Object$keys(validationState).map(field => {\n    if (validationState[field] === false) {\n      invalidFields.push(validationFieldMap[field]);\n    }\n  });\n\n  return invalidFields.join(', ');\n};\nexport const saveNewSuccess = name => toast.success(`Your ${name} has been successfully saved!`, {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success'\n});\nexport const saveChangesSuccess = () => toast.success(\"Your changes have been successfully saved!\", {\n  className: 'update-success',\n  progressClassName: 'progress-bar-success'\n});\nexport const saveNewError = (validationState, validationFieldMap, shallowValidation = false) => toast.error(`Please fill out the following required fields: ${shallowValidation ? shallowParseInvalidFieldsToString(validationState, validationFieldMap) : parseInvalidFieldsToString(validationState, validationFieldMap)}`, {\n  className: 'update-error',\n  progressClassName: 'progress-bar-error'\n});","map":null,"metadata":{},"sourceType":"module"}